# 1. 引用数据类型

**概念：** 除了基本数据类型之外，都是引用数据类型，包括类、数组、接口等等。

## 1.1 String类型

**概念：** `java.lang.String` 是我们学到的第一个引用数据类型，表示字符串。
- 格式：变量类型 变量名 = new 构造函数();
- 理解：变量类型 变量名 = new 变量类型();
    - eg： `A a = new A();`
    - eg： `String str = new String("Hello");`
- 特权：String可以使用基本数据类型的声明方式。

> java.lang 这个包下的所有的类可以直接使用。

## 1.2 API与API文档

**概念：** API（Application Programming Interface）就是应用程序编程接口，而API文档是记录这些接口的工具，习惯性翻阅API文档来学习一个类，是一个程序神的必备技能。
- [API官方概念](https://baike.baidu.com/item/api/10154)
- [JDK8官网API文档](`https://docs.oracle.com/javase/8/docs/api/index.html`)
- **API学习方法：**
    - 名称：代码需要使用名字去调用它，但是不需要记忆。
    - 修饰：是否为静态？非静态方法使用实例调用，静态方法使用类名调用。
    - 用途：这个必须记住，否则就跟没学一样。 
    - 参数：要求传入什么类型的变量，就传入什么类型的变量，不需要记忆。
    - 返回值：有返回值就用一个对应类型的变量去接收它的返回值，不需要记忆。  

**练习：** 01005-1-2
- 返回字符串"ABC"中2号位置上的字符。
- 将"DE"追加到"ABC"末尾。
- 返回"ABC"中是否包含"AC"。
- 返回"ABC"是否以"BC"结尾。
- 返回"ABC"是否以"B"开始。
- 返回"ABC"是否以"BC"开始。
- 返回"ABC"和"abc"是否相等。
- 返回"ABC"和"abc"是否相等，忽略大小写。
- 返回"ABC"中，"A"第一次出现的位置。
- 返回"ABC"中，"A"第一次出现的位置，（从1号位开始查找）。
- 返回"ABC"中，"A"最后一次出现的位置。
- 返回"ABC"中，"A"最后一次出现的位置，（从1号位开始查找）。
- 返回""是否是空字符串。
- 返回"林JUNJIE"有多少个字节。
- 返回将"ABCA"中的所有"A"都替换成"a"之后的字符串。
- 返回"ABCD"中2号位之后（包括2号位）的字符串。
- 返回"ABCD"中1号位（包括1号位）和2号位之间的字符串。
- 返回"ABCD"转成小写之后的字符串。
- 返回"ABCD"转成大写之后的字符串。
- 返回"  abcd  "两端去空格之后的字符串。
- 返回以"我叫%s，今年%d岁了，月薪%.2f元"为模板的格式化输出内容。
- 返回将一个布尔类型的true转换为字符串"true"的结果。
- 字符串"abcabcabc"，查找第一个a和最后一个a的位置。
- 字符串"abcabcabc"，查找第二个b的位置。
- 字符串"abcabcabc"，判断是否只有一个a。
- 字符串"abc abc abc"，删除所有的空格之后，截取第一个b和最后一个b中间的内容。
- 字符串"  abc ABCabc  "，去掉两端的空格之后，将字符串中的所有字母，都转成小写形式。

# 2. 正则表达式概念
 
**概念：** 
- 正则表达式，又称为规则表达式，`Regular Expression`，在代码中一般简写为 `regex` 或者 `RE`，是对字符串操作的一种逻辑公式，是用事先定义好的一些特定字符、及这些特定字符的组合，组成的一个"规则字符串模板"，用来表达对字符串的一种过滤逻辑。
- 正则表达式很灵活、有逻辑，可以迅速地用极简单的方式达到字符串的复杂控制。
- 一个正则表达式由三部分组成：
    - 普通字符：数字和字母，如 `abc` 、 `123` 等。
    - 特殊字符：具有功能的特殊字符，也称为元字符，如 `\d` ， `\s` 等。
    - 限定字符：限定个数的字符，如 `{10}` 、`{5, 9}`  、 `+` 、 `?` 等。
- 字符串对空格是敏感的，不要在字符串中随意使用空格。

> `^` 和 `$` 表示一个正则的开始和结束的精准定位，^表示开头，$表示结尾，需要视情况选择是否使用。

## 2.1 普通字符

字符|解析|成功案例|失败案例
-|-|-|-
`[abc]`  | 匹配 "abc" 中的任意一个字符 | `"a"` 或 `"b"` | `"d"` 或 `"ab"`
`[^abc]` | 匹配除 "abc" 以外的任意一个字符 | `"d"` 或 `"e"` | `"a"` 或 `"de"`
`[a-z]`  | 匹配a到z之间的任意一个字符 | `"a"` 或 `"b"` | `"A"` 或 `"38"`
`[^a-z]` | 匹配除了a到z之间的任意一个字符 | `"A"` 或 `"38"` | `"a"` 或 `"b"`

> "|" 表示或者，[]不能省略。

**练习：** 01005-2-1
1. 我的正则表达是是 `^[123]|[^b-d]$`，那么下面匹配的结果是：
- `System.out.println("2".matches(regex));`
- `System.out.println("c".matches(regex));`
- `System.out.println("12".matches(regex));`

## 2.2 特殊字符

字符|解析|成功|失败
-|-|-|-
`.`  | 匹配除 `\n` 和 `\r` 之外的任意一个字符 | `"a"` 或 `"%"` | `"\n"` 或 `"\r"`
`\d` | 匹配一个数字字符，等价于 `[0-9]` | `"0"` 或 `"9"` | `"e"` 或 `"10"`
`\D` | 匹配一个非数字字符，等价于 `[^0-9]` | `"e"` 或 `"10"` | `"0"` 或 `"9"`
`\n` | 匹配一个换行符 | `"\n"` | `"\\n"` 或 `"a"`
`\t` | 匹配一个制表符 | `"\t"` | `"\\t"` 或 `"a"`
`\w` | 匹配Unicode字母、数字和下划线 | `"_"` 或 `"a"` | `"\t"` 或 `"&"`
`\W` | 匹配除了Unicode字母、数字和下划线之外的字符 | `"\t"` 或 `"&"` | `"_"` 或 `"a"`

**练习：** 01005-2-2
1. 我的正则表达是是 `^\\d.\\w\\n$`，那么下面匹配的结果是：
- `System.out.println("2*a".matches(regex));`
- `System.out.println("2*a\n".matches(regex));`
- `System.out.println("2*a\\n".matches(regex));`

## 2.3 限定字符

字符|解析
-|-
`{n}`    | 恰好匹配n次
`{n,}`   | 至少匹配n次
`{n,m}`  | 匹配n到m次，n<=m，注意逗号和两个数之间不能有空格
`*`      | 匹配前面的子表达式任意次，等价于 `{0,}`
`+`      | 匹配前面的子表达式一次或多次，等价于 `{1,}`
`?`      | 匹配前面的子表达式零次或一次，等价于 `{0,1}`

> 表格中n和m均为非负整数。

**练习：** 01005-2-3
1. 我的正则表达是是 `^\\d{1,9}\\w*$`，那么下面匹配的结果是：
- `System.out.println("123a".matches(regex));`
- `System.out.println("123".matches(regex));`
- `System.out.println("a".matches(regex));`

## 2.4 正则三大用途

**概念：**
- 数据验证：用RE和某个字符串进行匹配，通过的返回布尔类型结果来分析该字符串是否满足规则。
    - 配合字符串的 `matches()` 完成验证。
    - `"18210210122".matches("^1\\d{10}$")`
- 替换文本：用RE来识别文档中的特定文本，完全删除它，或者用其他文本替换它。
    - 配合字符串的 `replaceAll()` 完成替换。
    - `"My Name Is 9527".replaceAll("[a-z]", "-");`
    - 这里不要使用 "^" 或者 "$"，的格式，否则将只会替换字符串的第一个或最后一个满足要求的元素。
- 提取子串：用RE从某个字符串中提取一部分内容，这部分内容称为子字符串。
    - 配合字符串的 `split()` 完成字符串切割。
    - `"Test A. Test B. Test C.".split("\\.\\s*");`
    - 这里不要使用 "^" 或者 "$"，的格式，否则将只会替换字符串的第一个或最后一个满足要求的元素。

# 3. String拓展类

**概念：** 一个String对象的长度和内容都是不可变的，虽然使用"+"可以达到改变内容的目的，但实质会产生一个或多个新的字符串，如果这种改变很频繁，那就会特别浪费内存，如果你的操作中需要频繁进行字符串的拼接，不建议使用 "+"。

**源码：** 使用 "+" 拼接10万次字符串耗时测试代码如下：
```java
@Test
public void plusSignStitchingTimeConsuming(){
    // 获取时间戳：距离1970年1月1日 0点0时0分 一个毫秒数。
    long startTime = System.currentTimeMillis();

    String str = "";
    for (int i = 0; i < 100000; i++) {
        str = str + i;
    }

    long endTime = System.currentTimeMillis();
    System.out.println("总耗时：" + (endTime - startTime) + "毫秒");
}
```

## 3.1 StringBuilder

**概念：**
- StringBuilder是jdk1.5版本提出来的一个类，它是一个可变长的字符串类，可以预分配缓冲区，我们可以通过它来进行频繁的字符串拼接操作。
- 创建方式：`StringBuilder stringBuilder = new StringBuilder("a");`
- 拼接方式：`append()`。
- 虽然在JDK1.8版本中，"+"的底层代码，也是在调用StringBuilder这个类的append()方法，但是多次调用"+"的时候，会创建多次StringBuilder，一样会导致效率低下，这里的优化仍未做到最好，所以在效率上，使用StringBuider仍然要比使用"+"，更优秀。

**源码：** 使用StringBuilder拼接10万次字符串耗时测试代码如下：
```java
@Test
public void stringBuilderStitchingTimeConsuming(){
    // 获取时间戳：距离1970年1月1日 0点0时0分 一个毫秒数。
    long startTime = System.currentTimeMillis();

    StringBuilder stringBuilder = new StringBuilder("");

    for (int i = 0; i < 100000; i++) {
        stringBuilder.append(i);
    }

    long endTime = System.currentTimeMillis();
    System.out.println("总耗时：" + (endTime - startTime) + "毫秒");
}
```

## 3.2 StringBuilder常用方法

方法|描述（n1和n2均指是索引位置）
-|-
`replace(n1, n2, "a");` | 将n1到n2之间的元素，全部替换成字符串"a"
`insert(n1, "a");` | 在n1之后，插入字符串"a"
`delete(n1, n2);` | 将n1到n2之间的元素，全部删除
`deleteCharAt(n1)` | 删除n1位置上的元素
`substring(n1, n2)` | 截取出n1到n2之间的所有元素并返回
`reverse()` | 水平翻转字符串
`toString()` | 以字符串形式展示

```!
以上范围均包括n1，但是不包括n2。
```

**练习：** 01005-3-2
1. 下面的返回值如果输出的话分别是什么？
- `new StringBuilder("love").replace(2, 3, "n").toString()`
- `new StringBuilder("how are you?").insert(4, "old ").toString()`
- `new StringBuilder("I not am ok!").delete(2, 6).toString()`
- `new StringBuilder("never").deleteCharAt(0).toString()`
- `new StringBuilder("female").substring(2, 6)`
- `new StringBuilder("evil").reverse().toString()`

## 3.3 StringBuffer

**概念：** StringBuffer是JDK1.0时代就存在的老员工了，它可以算是StringBuilder的亲生哥哥，它和StringBuilder的方法都是类似的，唯一的区别是，StringBuffer是线程安全的，而StringBuilder是线程不安全的。

**练习：** 01005-3-3
1. Which code fragment, inserted at line 24, outputs "123abc 123abc"?
```java
StringBuilder sb1 = new StringBuilder("123");
String s1 = "123";
// insert code here //24
System.out.println(sb1 + " " + s1);
```
- A. sb1.append("abc"); s1.append("abc");
- B. sb1.append("abc"); s1.concat("abc");
- C. sb1.concat("abc"); s1.append("abc");
- D. sb1.concat("abc"); s1.concat("abc");
- E. sb1.append("abc"); s1 = s1.concat("abc");
- F. sb1.concat("abc"); s1 = s1.concat("abc");
- G. sb1.append("abc"); s1 = s1 + s1.concat("abc");
- H. sb1.concat("abc"); s1 = s1 + s1.concat("abc");

2. What is the result?
```java
public class KungFu {
    public static void main(String[] args) {
        Integer x = 400;
        Integer y = x;
        x++; 
        StringBuilder sb1 = new StringBuilder("123");
        StringBuilder sb2 = sb1;
        sb1.append("5");
        System.out.println((x==y) + " " + (sb1==sb2));
    }
}
```
- A. true true
- B. false true
- C. true false
- D. false false
- E. Compilation fails.
- F. An exception is thrown at runtime.

3. Which two code fragments, inserted independently at line 3, generate the output 4247? (Choose two.)
```java
public class TestString3 {
    public static void main(String[] args) {
        // insert code here //3
        System.out.println(s);
    }
}
```
- A. String s = "123456789"; 
s = (s-"123").replace(1,3,"24") - "89";
- B. StringBuffer s = new StringBuffer("123456789"); 
s.delete(0,3).replace(1,3,"24").delete(4,6);
- C. StringBuffer s = new StringBuffer("123456789");
s.substring(3,6).delete(1,3).insert(1, "24");
- D. StringBuilder s = new StringBuilder("123456789");
s.substring(3,6).delete(1,2).insert(1, "24");
- E. StringBuilder s = new StringBuilder("123456789");
s.delete(0,3).delete(1,3).delete(2,5).insert(1, "24");

# 4. JVM内存分布

**概念：** 
- java程序在运行的时候，绝大部分的数据都在一块叫做运行时数据区（Runtime Data Area）的内存区域中活动。
- 运行时数据区，被划分成三块小的区域，分别被称为：
    - 栈内存：stack，相当于小区物业，空间小，功能少，访问方便。
    - 堆内存：heap，相当于小区住宅区，空间大，功能多，访问麻烦。
    - 方法区：Method Area，相当于小区广场，公共区域，所有人都可以访问。

## 4.1 内存地址

**概念：** 
- 基本数据类型全都分布在栈内存中。
- 引用数据类型的值分布在堆内存中，内存地址分布在栈内存中。
- **内存地址：** 也叫引用或者句柄，就像住宅区居民楼的门牌号，全部登记在物业，这样当我去找赵四的时候，只需要去栈中查找赵四家的门牌号就可以直接找到他家，并不需要去一个门一个门去敲问。

**源码：** 分析如下三行代码在内存中的分布：
```java
int a = 100;
double b = 10.5;
String str = new String("java");
```
![](https://user-gold-cdn.xitu.io/2020/3/22/1710116b200ca981?w=834&h=539&f=png&s=18988 "如上三行代码在JVM内存中的分布图")

## 4.2 基本和引用数据类型的区别

1. 基本类型只有8个，引用类型有无数个。
2. 声明一个基本类型时全部分布在栈内存中，而声明一个引用类型时，只会将内存地址存放在栈内存中，而值一般都放在堆中（使用new关键字进行开辟）。
3. 基本类型使用频繁，存取快，但是功能少，不附带任何方法，而引用类型，虽然使用起来比较麻烦，也比较占内存，但是功能多，每个引用数据类型都自带许多的方法供我们使用。

## 4.3 相等比较之==

**概念：**
- 基本类型在使用 `==` 进行比较的时候，直接按照数学规则比较变量值。
- 基本类型在使用 `==` 进行比较的时候，会将参与比较的双方都转换成同一类型，然后再进行比较，转换的目标类型，以参与比较的双方类型中，字节数大的一方为准。
- 引用类型在使用 `==` 进行比较的时候，比较的是内存地址。

**源码：** 引用类型的 `==` 比较测试。
```java
String str01 = new String("JoeZhou");
String str02 = new String("JoeZhou");

// str01 和 str02 有着不同的内存地址，返回F
System.out.println(str01 == str02);
```

**图示：** 引用类型的 `==` 比较测试
![](https://user-gold-cdn.xitu.io/2020/3/23/17105834b9a3e17b?w=999&h=673&f=png&s=23001)

## 4.4 相等比较之equals()

- 基本类型没有方法，所以无法使用 `equals()` 方法进行比较。
- `equals()` 方法来自于 `Object` 类（继承），原本的作用也是对内存地址进行比较，但是 `String` 类对其进行了重新改造（Override），使其变成了比较类型和值的一个方法。
- String类中的 `equals()` 方法先比较内存地址，如果内存地址不同，则比较字符串的内容。

# 5. 包装类

**概念：** 八个基本数据类型都有相对应的引用数据类型，叫做包装类。
- `Byte`/`Short`/`Integer`/`Long`/`Float`/`Double` 的父类是 `Number`。
- `Number` 的兄弟类是 `Boolean`，`Character`。

## 5.1 包装类的声明和赋值

**源码：**
```java
@Test
public void build() {
    System.out.println(new Byte((byte)100));
    System.out.println(new Short((short)200));
    System.out.println(new Integer(10000));
    System.out.println(new Long(10000000L));
    System.out.println(new Double(12.5));
    System.out.println(new Float(12.5F));
    System.out.println(new Character('a'));
    
    // System.out.println(new Boolean(true));
    // Boolean类型包装了更建议的一种声明方式
    System.out.println(Boolean.TRUE);
}
```

## 5.2 装箱和拆箱

**概念：** 
- 基本类型转成对应包装类的过程叫做装箱。
- 包装类转成对应基本类型的过程叫做拆箱。
- 在jdk1.5版本之前，需要我们手动拆装箱。
    - 手动拆箱：`Integer.valueOf(num)`
    - 手动装箱：`num.intValue()`
- 在jdk1.5版本之后，JVM自动拆装箱，代码上直接使用等号赋值即可。

**练习：** 01005-5-2
1. What is the result when method testIfA is invoked?
```java
public void testIfA() {
    if (testIfB("True")) {//12
        System.out.println("True");
    } else {
        System.out.println("Not true");
    }
}
public Boolean testIfB(String str) {
    return Boolean.valueOf(str);//19
}
```
- A. True
- B. Not true
- C. An exception is thrown at runtime.
- D. Compilation fails because of an error at line 12.
- E. Compilation fails because of an error at line 19.