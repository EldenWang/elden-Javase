# 1. 运算符

## 1.1 数学运算符

**概念：** 
- 基本运算：包括加（`+`），减（`-`），乘（`*`），除（`/`）。
    - 除法运算中，如果操作数都是整数，则结果也是整数。
- 取余运算：取余运算符（`%`），0取余任何数都等于0，正负号只和等号左边操作数的一致。
- 自运算：
    - 自运算 `++` / `--` 即给自身加1或减1。
    - 自运算优先级最高。
    - 自运算只能用在变量上，常量没有自运算。
    - 自运算分为先用后加(a++)和先加后用(++a);

**练习：** 01006-1-1
1. What is the result?
```java
int a = 13 , b = 3;
System.out.println(++a + b);
System.out.println(a-- - b);
System.out.println(a);
System.out.println(b);
```

2. What is the result?
```java
int a = 1;
System.out.println(++a + a++ + a++ + a);
System.out.println(a);
```

## 1.2 赋值运算符

**概念：** java中使用一个等号表示赋值，赋值要从后向前理解：
- `+=`：追加，`a += b` 就等价于 `a = a+b`，将 `a+b` 的结果重新赋值给 `a`
- `-=`：追减，`a -= b` 就等价于 `a = a-b`，将 `a-b` 的结果重新赋值给 `a`
- `*=`：追乘，`a *= b` 就等价于 `a = a*b`，将 `a*b` 的结果重新赋值给 `a`
- `/=`：追除，`a /= b` 就等价于 `a = a/b`，将 `a/b` 的结果重新赋值给 `a`
- `%=`：追取余，`a %= b` 就等价于 `a = a%b`，将 `a+b` 的结果重新赋值给 `a`

**练习：** 01006-1-2
1. What is the result?
```java
int a = 13, b = 3;
System.out.println(a += b);
System.out.println(a -= b);
System.out.println(a *= b);
System.out.println(a /= b);
System.out.println(a %= b);
```

2. What is the result?
```java
int a = 10;
System.out.println(a %= 11);
```

3. What is the result?
```java
int a = 10;
System.out.println(a /= 10 + 6);
```

## 1.3 关系运算符

**概念：** 关系运算一定会返回boolean类型的值，运算符包括：`==` / `>` / `<` / `>=` / `<=` / `!=`。

**练习：** 01006-1-3
1. What is the result?
```java
System.out.println(1 == 2 == true);
```

## 1.4 逻辑运算符

**概念：** 逻辑运算包括逻辑与(`&&`)，逻辑或(`||`)和逻辑非(`!`)。
- 口诀：与中有假(则假)，或中有真(则真)。
- 逻辑运算优先级：非 > 与 > 或。

**练习：** 01006-1-4
1. What is the result?
```java
System.out.println(false && true);
System.out.println(true || false);
System.out.println(true || false && false || true);
System.out.println(true || false && false || false);
```

## 1.5 位运算符和短路现象

**概念：** 
- 位运算包括位与(`&`)，位或(`|`)和取反(`~`)。
- 逻辑运算会发生短路现象，而位运算不会。

**练习：** 01006-1-5
1. What is the result?
```java
int a = 1;
System.out.println(1 == 2 && a++ == 2);
System.out.println(a);
```

## 1.6 三元运算符

**概念：** 三目运算符，也叫三部运算符，也叫三元运算符。
- 公式：`X ? Y : Z`，其中X为布尔类型表达式，当X的结果为true时返回Y，否则返回Z。
- Y和Z的返回值类型必须一致。
- 三目运算符一定要接它的返回值，它的返回值类型就是你Y和Z的返回值类型。

**练习：** 01006-1-6
1. 利用三目运算符，如果分数小于0,分数有问题，如果分数在0-60之间，显示不及格，如果分数在61-80之间，显示及格，如果分数在81-100之间，显示优秀，如果分数在100以上，显示分数有问题。
2. 请使用三目运算符编写一个"两数比大小程序"，要求有 "大"， "小"，和 "相等" 三种结果。
3. 请使用三目运算符编写一个"两数比大小程序"，谁大输出谁，相等输出 "相等"。

# 2. 数学工具类

**概念：** `java.lang.Math` 工具类提供了大量用于数学运算的方法，Math类是final类，因此不能从Math类继承，Math类中的方法都是static方法，因此不必创建Math类的对象就可以直接使用类的方法。
- `Math.abs(-10)`：绝对值；
- `Math.sqrt(16)`：平方根
- `Math.cbrt(8)`：立方根
- `Math.ceil(2.1)`：向上取整
- `Math.floor(2.9)`：向下取整
- `Math.max(1, 6)`：最大值 
- `Math.min(1, 6)`：最小值 
- `Math.pow(2, 3)`：a的b次幂
- `Math.round(2.4)`：四舍五入
- `Math.random()`：随机数：每次随机都生成一个[0-1)之间的数字

> 随机数生成的代码，更建议使用 `new Random().nextInt(5);`，此时可以直接随机生成一个0到5范围内的int值。

**练习：** 01006-2
1. 每次随机都生成一个5-10之间的数字。

# 3. Scanner工具类

**概念：** `java.util.Scanner` 是JDK1.5之后引入的功能类，负责接收控制台上输入的字符，将其转换为相应数据类型的数据，并存储到相应的变量中。
- Scanner的特性规定我们在new它的时候，传一个固定的值 `System.in` 进去，代表输入流；
    - `Scanner scanner = new Scanner(System.in);` 
    - `scanner.close();`
    - `scanner.nextInt()`：接收控制台传递过来的整数。
    - `scanner.nextDouble()`：接收控制台传递过来的浮点数。
    - `scanner.next()`：接收控制台传递过来的字符串。

> IDEA中无法使用Junit测试Scanner，请换成main方法测试。

**练习：** 01006-3
1. 请利用三元运算符和Scanner做一个计算器程序，要求如下：
- 要求1：计算器具有提示内容，运算法则及编号。
- 要求2：计算器拥有加、减、乘、除、取余数五大功能。
- 要求3：用户在控制台依次输入[数据1 > 运算法则编号 > 数据2]，可以得到正确的运算结果。

# 4. 数值溢出问题

**概念：** 
- 我们都知道变量是有自己的存值范围的，比如 byte 的存值范围是-128 ~ 127之间，那么假设在计算的时候发生了数值溢出，会产生物极必反的现象：
    - 最大值加1变成最小值
    - 最小值减1变成最大值
- 二进制计算的原理：将原码转成补码，使用补码进行计算，再将结果转回原码。
- 模拟 2147483647 + 1 的过程
    - 原码： [01111111 11111111 11111111 11111111]
    - 反码： [01111111 11111111 11111111 11111111]，与原码相同
    - 补码： [01111111 11111111 11111111 11111111]，与原码相同
    - 加一： [10000000 00000000 00000000 00000000]，计算会影响符号位，toBinaryString()方法会打印这个值
    - 反码： [11111111 11111111 11111111 11111111]，符号位不动，其余按位取反
    - 补码： [10000000 00000000 00000000 00000000]，反码 + 1，符号位不参与补码进位
    - 真值： -2147483648（int最小值）
- 模拟 -2147483648 - 1 的过程
    - 原码： [10000000 00000000 00000000 00000000]
    - 反码： [11111111 11111111 11111111 11111111]，符号位不动，其余按位取反
    - 补码： [10000000 00000000 00000000 00000000]，反码 + 1，符号位不参与补码进位
    - 减一： [01111111 11111111 11111111 11111111]，计算会影响符号位，toBinaryString()方法会打印这个值
    - 反码： [01111111 11111111 11111111 11111111]，与原码相同
    - 补码： [01111111 11111111 11111111 11111111]，与原码相同
    - 真值： 2147483647（int最大值）

**测试：**
```java
@Test
public void numericalOverflow() {
    int maxValueOfInt = 2147483647;
    int result = maxValueOfInt + 1;
    System.out.println(result);
}

@Test
public void integerLimitTest() {   
    // 01111111 11111111 11111111 11111111
    System.out.println(Integer.toBinaryString(2147483647));
    
    // 10000000 00000000 00000000 00000000
    System.out.println(Integer.toBinaryString(-2147483648));
    
    // 10000000 00000000 00000000 00000000
    System.out.println(Integer.toBinaryString(2147483647 + 1));
    
    // 01111111 11111111 11111111 11111111
    System.out.println(Integer.toBinaryString(-2147483648 - 1));
}
```

**练习：** long result = 2147483647 + 1;会溢出吗？