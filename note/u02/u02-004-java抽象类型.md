# 1. 抽象类

**概念：** 
- **抽象类：** 被 `abstract` 修饰的类叫做抽象类，可以理解为"半残类"，它有完整的构造方法，但不能直接调用，而是依靠子类构造方法来间接调用，从而完成实例化过程。
- **抽象方法：** 被 `abstract` 修饰且没有方法体的方法叫抽象方法，不能被 `private` 和 `final` 修饰。
- 抽象类中不一定有抽象方法，但拥有抽象方法的类一定得声明为抽象类。
- 抽象类命名应建议以Abstract或Base开头。

**源码：** BaseStartDemo.java
```java
/**
 * @author JoeZhou
 */
public abstract class BaseStartDemo {
    public void methodA() {
        System.out.println("methodA");
    }
    public abstract void methodB();
    public abstract void methodC();
}
```

> 实际上抽象类就是允许比普通类多一个抽象方法，且不能直接创建本类型而已。

# 2. 抽象方法实现

**概念：** 抽象类的实例化可以使用它的子孙类来完成继承重写的过程。

**源码：** MyStartDemo.java，BaseStartDemo.java见第一节源码
```java
/**
 * @author JoeZhou
 */
public class MyStartDemo extends BaseStartDemo {
    @Override
    public void methodB() {
        System.out.println("子类重写了methodB...");
    }
    @Override
    public void methodC() {
        System.out.println("子类重写了methodC...");
    }
}
```

**源码：**
```java
@Test
public void buildBySubClass() {
    BaseStartDemo baseStartDemo = new MyStartDemo();
    baseStartDemo.methodA();
    baseStartDemo.methodB();
    baseStartDemo.methodC();
}
```

**练习：** 02004-2
1. (Y/N)抽象类中可不可以没有抽象方法？
2. (Y/N)抽象类中可不可以有抽象方法？
3. (Y/N)抽象类中可不可以有普通方法？
4. (Y/N)抽象类可不可以被final修饰？
5. (Y/N)抽象方法可不可以被private修饰？
6. (Y/N)抽象方法可不可以被final修饰？

# 3. 接口

**概念：** 接口也是一个特殊的类，但是它规定：
- 接口中的属性都是默认被 `public static final` 修饰的。
- 接口中的方法都是默认被 `public abstract` 修饰的。
- 如果说抽象类是一个半残的类，那么接口就是一个全残的类。
- 接口需要将 `class` 关键字替换为 `interface`。

**源码：**
```java
/**
 * @author JoeZhou
 */
public interface UserService {
    public static final String NAME = "123";
    String GENDER = "female";
    
    /**测试方法A*/
    public abstract void methodA();
    /**测试方法B*/
    void methodB();
}
```

# 4. 接口方法实现

**概念：** 接口和抽象类一样，要由子孙类来实现（不再叫做继承），通过 `implements` 关键字来完成。
- 接口一般直接命名，实现类在接口同包下新建子包 `impl`，然后实现类的名称就是接口名称并添加 `Impl` 后缀，如：
    - 接口名：`com.joe.service.UserService`
    - 实现类：`com.joe.service.impl.UserServiceImpl`

> 父子类关系中，如果创建一个子类，需要先去调用父类的构造器，然而接口没有构造器，所以子普通类或子抽象类不能继承父接口，但是子接口可以继承父接口，因为子类接口也无法被调用构造器。

**源码：** UserService.java
```java
/**
 * @author JoeZhou
 */
public interface UserService {
    String NAME = "赵四";
    String GENDER = "female";

    /**测试方法A*/
    void methodA();
}
```

**源码：** UserServiceImpl.java
```java
/**
 * @author JoeZhou
 */
public class UserServiceImpl implements UserService {
    @Override
    public void methodA() {
        System.out.println("实现了methodA...");
    }
}
```

**源码：**
```java
@Test
public void userServiceBySubClass() {
    UserService userService = new UserServiceImpl();
    System.out.println(UserService.NAME);
    System.out.println(UserService.GENDER);
    userService.methodA();
}
```

**练习：** 02004-4
1. Which three are valid on line12?(Choose three.)
```java
public interface Status {
    /* insert code here 12 */ int MY_VALUE = 10;
} 
```
- A. final
- B. static
- C. native
- D. public
- E. private
- F. abstract
- G. protected

2. Which statement is true about the classes and interfaces in the exhibit?
![](https://user-gold-cdn.xitu.io/2020/7/27/1738e75429d28d11?w=540&h=469&f=jpeg&s=48309)
- A. Compilation will succeed for all classes and interfaces.
- B. Compilation of class C will fail because of an error in line 2.
- C. Compilation of class C will fail because of an error in line 6.
- D. Compilation of class AImpl will fail because of an error in line 2.

3. When line 15 is reached, how many objects are eligible for the garbage collector?
```java
interface Animal { void makeNoise(); }
class Horse implements Animal {
    Long weight = 1200L;
    public void makeNoise() { System.out.println("whinny"); }
}
public class Icelandic extends Horse {
    public void makeNoise() { System.out.println("vinny"); }
    public static void main(String[] args) {
        Icelandic i1 = new Icelandic();
        Icelandic i2 = new Icelandic();
        Icelandic i3 = new Icelandic();
        i3 = i1; i1 = i2; i2 = null; i3 = i1;
    }// 15
}
```
- A. 0
- B. 1
- C. 2
- D. 3
- E. 4
- F. 6

4. What is the result?
```java
interface A { public void aMethod(); }//1
interface B { public void bMethod(); }
interface C extends A,B { public void cMethod(); }
class D implements B {
    public void bMethod(){}
}
class E extends D implements C {
    public void aMethod(){}
    public void bMethod(){}// 9
    public void cMethod(){}
}
```
- A. Compilation fails because of an error in line 3.
- B. Compilation fails because of an error in line 7.
- C. Compilation fails because of an error in line 9.
- D. If you define D e = new E(), then e.bMethod() invokes the version of bMethod() defined in Line 5.
- E. If you define D e = (D)(new E()), then e.bMethod() invokes the version of bMethod() defined in Line 5.
- F. If you define D e = (D)(new E()), then e.bMethod() invokes the version of bMethod() defined in Line 9.

5. What is the result?
```java
class Animal { public String noise() { return "peep"; } }
class Dog extends Animal { 
    public String noise() { return "bark"; }
}
class Cat extends Animal {
    public String noise() { return "meow"; }
} ...
Animal animal = new Dog();
Cat cat = (Cat)animal;
System.out.println(cat.noise());
```
- A. peep
- B. bark
- C. meow
- D. Compilation fails.
- E. An exception is thrown at runtime.

6. What is the result?
```java
public class Base {
    public static final String FOO = "foo";
    public static void main(String[] args) {
        Base b = new Base();
        Sub s = new Sub();
        System.out.print(Base.FOO);
        System.out.print(Sub.FOO);
        System.out.print(b.FOO);
        System.out.print(s.FOO);
        System.out.print(((Base)s).FOO);
    }
}
class Sub extends Base {public static final String FOO = "bar";} 
```
- A. foofoofoofoofoo
- B. foobarfoobarbar
- C. foobarfoofoofoo
- D. foobarfoobarfoo
- E. barbarbarbarbar
- F. foofoofoobarbar
- G. foofoofoobarfoo

7. What is the result?
```java
interface DeclareStuff {
    public static final int EASY = 3;
    void doStuff(int t); 
}
public class TestDeclare implements DeclareStuff {
    public static void main(String [] args) {
        int x = 5;
        new TestDeclare().doStuff(++x);
    }
    void doStuff(int s) {
        s += EASY + ++s;
        System.out.println("s " + s);
    }
}
```
- A. s 14
- B. s 16
- C. s 10
- D. Compilation fails.
- E. An exception is thrown at runtime.

8. Click the Exhibit button. What is the result?
![](https://user-gold-cdn.xitu.io/2020/7/27/1738e7623a3fcfc0?w=507&h=382&f=jpeg&s=56464)
- A. go in Goban	go in Sente
- B. go in Sente	go in Goban
- C. go in Sente	go in Goban		go in Goban
- D. go in Goban 	go in Sente 		go in Goban
- E. Compilation fails because of an error in line 17.

9. What is the result?
```java
public interface A111 {
    String s = "yo";
    public void method1();// 12
}
interface B { }
interface C extends A111, B {// 20
    public void method1();// 21
    public void method1(int x);// 22
}
```
- A. Compilation succeeds.
- B. Compilation fails due to multiple errors.
- C. Compilation fails due to an error only on line 20.
- D. Compilation fails due to an error only on line 21.
- E. Compilation fails due to an error only on line 22.
- F. Compilation fails due to an error only on line 12.

10. Which two methods, inserted independently at line 17, correctly complete the Sales class? (Choose two.)
```java
abstract public class Employee {
    protected abstract double getSalesAmount();
    public double getCommision() {
        return getSalesAmount() * 0.15;
    }
}
class Sales extends Employee {
    // insert method here
}
```
- A. double getSalesAmount() { return 1230.45; }
- B. public double getSalesAmount() { return 1230.45; }
- C. private double getSalesAmount() { return 1230.45; }
- D. protected double getSalesAmount() { return 1230.45; }

11. What is the result?
```java
abstract class C1 {
    public C1() { System.out.print(1); }
}
class C2 extends C1 {
    public C2() { System.out.print(2); }
}
class C3 extends C2 {
    public C3() { System.out.println(3); }
}
public class Ctest {
    public static void main(String[] a) { new C3(); }
}
```
- A. 3
- B. 23
- C. 32
- D. 123
- E. 321
- F. Compilation fails.
- G. An exception is thrown at runtime.

12. Which two methods, inserted individually, correctly complete the Three class? (Choose two.)
```java
class One {
    public One foo() { return this; }
}
class Two extends One {
    public One foo() { return this; }
}
class Three extends Two {
    // insert method here
}
```
- A. public void foo() {}
- B. public int foo() { return 3; }
- C. public Two foo() { return this; }
- D. public One foo() { return this; }
- E. public Object foo() { return this; }

# 5. 抽象类和接口的区别

**总结：**
1. 抽象类有构造方法，接口没有构造方法。
2. 抽象类可以有非抽象的方法（部分抽、半残），接口中的方法都是抽象的（全抽、全残）。
3. 接口中的属性都是PSF固定修饰的，而抽象类无此规定。
4. 接口中的方法都是PA固定修饰的，而抽象类无此规定。
5. 抽象类可以继承其它的类，接口不能继承其他类。
6. 类与抽象类是单继承关系（单继承），类可以同时实现多个接口（多实现），且接口和接口之间是多继承。
7. 抽象类和它的子类是 `is a` 的关系，接口和它的实现类是 `like a` 的关系。

**练习：** 02004-5
1. (Y/N)抽象类能继承普通类吗？
2. (Y/N)普通类能继承两个抽象类吗？
3. (Y/N)抽象类能继承两个普通类吗？
4. (Y/N)抽象类能继承接口吗？
5. (Y/N)抽象类能继承两个接口吗？
6. (Y/N)接口能继承抽象类吗？
7. (Y/N)接口能继承两个抽象类吗？
8. (Y/N)普通类能继承接口吗？
9. (Y/N)普通类能继承两个接口吗？
10. (Y/N)接口能继承普通类吗？
11. (Y/N)接口能继承两个普通类吗？
12. (Y/N)普通类能继承普通类吗？
13. (Y/N)普通类能继承两个普通类吗？
14. (Y/N)抽象类能继承抽象类吗？
15. (Y/N)抽象类能继承两个抽象类吗？
16. (Y/N)接口能继承接口吗？
17. (Y/N)接口能继承两个接口吗？
18. (Y/N)普通类能实现接口吗？
19. (Y/N)普通类能实现两个接口吗？
20. (Y/N)抽象类能实现接口吗？
21. (Y/N)抽象类能实现两个接口吗？
22. (Y/N)接口能实现接口吗？
23. (Y/N)接口能实现两个接口吗？

# 6. 工厂模式

**流程：**
1. 设计接口 `Car` 和接口方法 `drive()`。
2. 设计奔驰实现类 `Benz`。
4. 测试：创建一辆奔驰实例并调用 `drive()`。

**源码：** Car.java
```java
/**
 * @author JoeZhou
 */
public interface Car {
    /**驾驶方法*/
    void drive();
}
```

**源码：** Benz.java
```java
/**
 * @author JoeZhou
 */
public class Benz implements Car {
    @Override
    public void drive() {
        System.out.println("奔驰在跑...");
    }
}
```

**源码：**
```java
@Test
public void factory() {
    new Benz().drive();
}
```

**总结：** `factory()` 即是生产者，负责造车又是使用者，负责开车，这不符合工厂模式的理念。

## 6.1 静态工厂

**概念：** 静态工厂模式（也称简单工厂）的目的就是想要将生产者和使用者分离，生产者只负责生产，使用者只负责使用。

**流程：**
1. 保留接口 `Car` 和奔驰实现类 `Benz`。
2. 设计工厂类 `CarFactory`。
3. 设计工厂方法 `getBenz()`：返回一个奔驰实例。
4. 测试：从工厂类中获取一辆奔驰实例并调用 `drive()`。

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public class CarFactory {
    public static Car getBenz() {
        return new Benz();
    }
    public static Car getBmw() {
        return new Bmw();
    }
}
```

**源码：**
```java
@Test
public void staticFactory() {
    CarFactory.getBenz().drive();
}
```

**总结：** 静态工厂做到了生产者和使用者的分离，但它不满足OCP开闭原则，因为一旦你想再添加一辆新品牌的车，则需要修改实现类 `CarFactory` 的内容。

> OCP开闭原则：`Open-Closed Principle：` 一个软件的实体应当对添加拓展开放，对修改重构关闭。

## 6.2 工厂方法

**概念：** 与静态工厂不同，工厂方法模式不将 `CarFactory` 定义为类，而是定义为接口。

**流程：**
1. 保留接口 `Car` 和奔驰实现类 `Benz`。
2. 设计工厂接口 `CarFactory`。
3. 设计工厂接口方法 `build()`：返回一辆车的实例。
4. 设计奔驰工厂接口实现类 `BenzFactory` 实现 `CarFactory`，专门负责造奔驰。

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public interface CarFactory {
    /**
     * 构建一辆车的实例
     * @return 车的接口实例
     */
    Car build(); 
}
```

**源码：** BenzFactory.java
```java
/**
 * @author JoeZhou
 */
public class BenzFactory implements CarFactory {
    @Override
    public Car build() {
        return new Benz();
    }
}
```

**源码：**
```java
@Test
public void factoryMethod() {
    new BenzFactory().build().drive();
}
```

**总结：** 
- 工厂方法满足OCP原则，因为你添加一辆奥迪，不需要去修改任何一个类或接口的内容，而是再添加一个奥迪类 `AuDi` 和奥迪工厂接口实现类 `AuDiFactory`。
- 但是它的缺点也显而易见，你需要让使用者去new对应的车厂，所以这种模式，理论上优于静态工厂，但实际开发中还是静态工厂用的比较多。

## 6.3 抽象工厂

**概念：** 抽象工厂模式在大型的项目中才会遇得到，这种工厂模式并不是对单独的产品（发动机/轮胎/内饰）进行操作，而是对一条产品族（发动机+轮胎）进行整体操作。

**流程：**
1. 设计一个轮胎的接口 `Tires` 和两个轮胎的实现类：`GoodTires` 和 `BadTires`。
2. 设计一个发动机的接口 `Engine` 和两个发动机的实现类：`GoodEngine` 和 `BadEngine`。
3. 设计一个车厂接口 `CarFactory`，负责制造轮胎和发动机等，有两个实现类：`GoodCarFactory` 和 `BadCarFactory`。
4. 在使用的时候，创造一个好车厂或者坏车厂，就可以决定创造出来的零件都是好的或都是坏的。

**源码：** Tires.java
```java
/**
 * @author JoeZhou 
 */
public interface Tires {
    /**轮胎信息*/
    void info();
}
```

**源码：** GoodTires.java
```java
/**
 * @author JoeZhou 
 */
public class GoodTires implements Tires {
    @Override
    public void info() {
        System.out.println("好轮胎...");		
    }
}
```

**源码：** BadTires.java
```java
/**
 * @author JoeZhou
 */
public class BadTires implements Tires {
    @Override
    public void info() {
        System.out.println("坏轮胎...");
    }
}
```

**源码：** Engine.java
```java
/**
 * @author JoeZhou 
 */
public interface Engine {
    /**发动机信息*/
    void info();
}
```

**源码：** GoodEngine.java
```java
/**
 * @author JoeZhou
 */
class GoodEngine implements Engine {
    @Override
    public void info() {
        System.out.println("好发动机...");
    }
}
```

**源码：** BadEngine.java
```java
/**
 * @author JoeZhou
 */
class BadEngine implements Engine {
    @Override
    public void info() {
        System.out.println("坏发动机...");
    }
}
```

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public interface CarFactory {
    /**
     * 获取发动机
     * @return 发动机实例
     */
    Engine getEngine();

    /**
     * 获取轮胎
     * @return 轮胎实例
     */
    Tires getTires();
}
```

**源码：** GoodCarFactory.java
```java
/**
 * @author JoeZhou
 */
public class GoodCarFactory implements CarFactory {

    @Override
    public Engine getEngine() {
        return new GoodEngine();
    }

    @Override
    public Tires getTires() {
        return new GoodTires();
    }
}
```

**源码：** BadCarFactory.java
```java
/**
 * @author JoeZhou
 */
public class BadCarFactory implements CarFactory {

    @Override
    public Engine getEngine() {
        return new BadEngine();
    }

    @Override
    public Tires getTires() {
        return new BadTires();
    }
}
```

**源码：**
```java
@Test
public void abstractFactory(){
    // by good
    CarFactory goodFactory = new GoodCarFactory();
    goodFactory.getEngine().info();
    goodFactory.getTires().info();
    
    // by bad
    CarFactory badFactory = new BadCarFactory();
    badFactory.getEngine().info();
    badFactory.getTires().info();
}
```

**总结：** 这种工厂模式满足OCP原则，因为想加一条产品族，不需要改变原来的"车厂+零件"的产品族，而是再去添加一个"水果厂+配料"，或者"粮食厂+粮食"等即可。
